% !TEX program = pdflatex
\documentclass[12pt]{article}

% --------- Paquetes básicos ----------
\usepackage[spanish,es-noshorthands]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

% --------- Formato ----------
\usepackage[a4paper,margin=2.5cm]{geometry}
\usepackage{setspace}
\onehalfspacing
\usepackage{parskip}

% --------- Matemáticas ----------
\usepackage{amsmath,amssymb}

% --------- Figuras y tablas ----------
\usepackage{graphicx}
\usepackage{float}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{siunitx}

% --------- Código ----------
\usepackage{listings}
\usepackage{xcolor}
\lstdefinelanguage{Julia}{
  morekeywords={
    abstract,break,case,catch,const,continue,do,else,elseif,end,export,false,finally,for,function,
    global,if,import,in,let,local,macro,module,mutable,primitive,quote,return,struct,true,try,using,
    while,where
  },
  sensitive=true,
  morecomment=[l]\#,
  morestring=[b]",
}

% 2. Luego creamos el estilo apuntando al lenguaje que acabamos de crear
\lstdefinestyle{juliastyle}{
  language=Julia,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue},
  commentstyle=\color{gray},
  stringstyle=\color{teal},
  numbers=left,
  numberstyle=\tiny\color{gray},
  stepnumber=1,
  numbersep=8pt,
  showstringspaces=false,
  breaklines=true,
  frame=single,
  tabsize=2
}

% 3. Aplicamos el estilo por defecto
\lstset{style=juliastyle}
% --------- Hipervínculos ----------
\usepackage[hidelinks]{hyperref}

% --------- Título ----------
\title{\textbf{Comparación de Memoria y Tiempo en Algoritmos de Búsqueda Top-1}}
\author{Javier Jhairt López Rojas}
\date{\today}

\begin{document}
\maketitle

% =========================================================
\section{Introducción}
Este reporte analiza el consumo de memoria y el tiempo de ejecución al resolver la búsqueda top-1 (encontrar el vector $x \in X$ que maximice el producto punto con $q \in Q$). Básicamente, comparamos qué es más eficiente en la práctica: multiplicar matrices de golpe o usar ciclos iterativos con referencias.
% =========================================================
\section{Metodología}
\subsection{Supuestos}

Los supuestos realizados para el desarrollo de esta practica son los siguientes:

\begin{itemize}
    \item Entrada de datos y dimensiones: Se analizarán combinaciones de $m \in \{10^3, 10^6, 10^9\}$, $n \in \{10^3, 10^6, 10^9\}$ y dimensiones $d \in \{8, 16, 32\}$.
    \item Normalización: Las matrices $Q$ y $X$ contienen datos aleatorios cuyos vectores columna están normalizados sobre la esfera unitaria, por lo que maximizar el producto punto es matemáticamente equivalente a minimizar la distancia coseno.
    \item Tipos de datos: En un mundo real, para evitar daños de hardware y saturación de memoria RAM (Out of Memory), se asume el uso de datos de tipo \texttt{Float32} (4 bytes) e \texttt{Int64} (8 bytes).
\end{itemize}

\subsection{Herramientas y entorno}
Los experimentos se realizaron en el lenguaje de programación Julia. Se utilizaron las estructuras de control nativas, la librería \texttt{LinearAlgebra} para las operaciones vectoriales, y la macro \texttt{@time} para reportar los costos reales de ejecución y asignación de memoria. Para las gráficas se usó la librería \texttt{Plots}.

% =========================================================
\section{Implementación de Algoritmos A1 y A2}

\subsection{Algoritmo A1: Operaciones matriciales explícitas}
Este algoritmo realiza el producto matricial completo $P = Q^T X$, calculando todos los pares posibles en un solo paso, para luego extraer el máximo de cada fila.



\subsection{Algoritmo A2: Adaptación con referencias}
Este algoritmo adapta la función \texttt{getmaxdot}, iterando sobre las columnas de $Q$ y calculando los productos punto bajo demanda usando \texttt{@view} o referencias abstractas para no copiar grandes bloques de memoria.


% =========================================================
\section{Análisis de memoria necesaria}

Se analiza la memoria asintótica requerida. El algoritmo A1 tiene una complejidad espacial de $O(m \times n)$ ya que debe alojar la matriz $P$. El algoritmo A2 tiene un costo $O(m)$ pues solo guarda los vectores de resultados \texttt{nns} y \texttt{dots}.

\begin{longtable}{@{}llll@{}}
    \caption{Memoria extra requerida para A1 vs A2 (usando Float32 e Int64).}\label{tab:sim_memoria} \\
    \toprule
    $m$ (cols de Q) & $n$ (cols de X) & A1 ($O(m \times n)$)         & A2 ($O(m)$)                   \\ \midrule
    \endfirsthead
    \toprule
    $m$ (cols de Q) & $n$ (cols de X) & A1 ($O(m \times n)$)         & A2 ($O(m)$)                   \\ \midrule
    \endhead
    \bottomrule
    \endfoot
    $10^3$          & $10^3$          & $\approx \SI{4}{\mega\byte}$ & $\approx \SI{12}{\kilo\byte}$ \\
    $10^3$          & $10^6$          & $\approx \SI{4}{\giga\byte}$ & $\approx \SI{12}{\kilo\byte}$ \\
    $10^3$          & $10^9$          & $\approx \SI{4}{\tera\byte}$ & $\approx \SI{12}{\kilo\byte}$ \\ \midrule
    $10^6$          & $10^3$          & $\approx \SI{4}{\giga\byte}$ & $\approx \SI{12}{\mega\byte}$ \\
    $10^6$          & $10^6$          & $\approx \SI{4}{\tera\byte}$ & $\approx \SI{12}{\mega\byte}$ \\
    $10^6$          & $10^9$          & $\approx \SI{4}{\peta\byte}$ & $\approx \SI{12}{\mega\byte}$ \\ \midrule
    $10^9$          & $10^3$          & $\approx \SI{4}{\tera\byte}$ & $\approx \SI{12}{\giga\byte}$ \\
    $10^9$          & $10^6$          & $\approx \SI{4}{\peta\byte}$ & $\approx \SI{12}{\giga\byte}$ \\
    $10^9$          & $10^9$          & $\approx \SI{4}{\exa\byte}$  & $\approx \SI{12}{\giga\byte}$ \\
\end{longtable}

Discusión: Es interesante observar que A1 colapsará la memoria de una computadora convencional al cruzar el umbral de $m=10^3, n=10^6$, mientras que A2 permanece altamente eficiente incluso para $m=10^9$.

% =========================================================
\section{Reporte de costos en tiempo real}

Para una corrida con los argumentos $m = 10^3$, $n = 10^6$ y $d = 16$, se reportaron los siguientes costos en consola de Julia:

\begin{itemize}
    \item \textbf{A1}: $11.161083$ seconds (1.64 k allocations: $3.725$ GiB)
    \item \textbf{A2}: $5.875192$ seconds (2.01 k allocations: $136.969$ KiB)
\end{itemize}

Discusión: Podemos notar que A2 fue sustancialmente más rápido que A1. Esto sucede porque A1 se ve estrangulado por el cuello de botella físico de asignar y escribir casi $4$ GB de memoria RAM. A2, al procesar cada producto punto al vuelo sin guardar la matriz entera, aprovecha la memoria caché del procesador, reduciendo drásticamente las asignaciones a solo unos \SI{136}{\kilo\byte}.

% =========================================================
\section{Distribución del arreglo \textit{dots}}

\begin{figure}[H]
    \centering
    \caption{Distribución de los valores máximos del producto punto para la corrida $m=10^3, n=10^6, d=16$.}
    \includegraphics[width=0.8\textwidth]{images/distribucion_dots.png}
    \label{fig:dist_dots}
\end{figure}

Discusión: Se puede apreciar que la distribución está fuertemente sesgada a la derecha, con valores muy próximos a 1.0. Al existir un millón de candidatos en la esfera unitaria en un espacio de solo 16 dimensiones, la probabilidad matemática de encontrar un vector casi colineal es sumamente alta.

% =========================================================
\newpage
\section{Conclusiones}

De esta práctica nos quedan dos cosas claras. Primero, la gráfica demuestra que al buscar entre un millón de vectores en solo 16 dimensiones, casi siempre encontraremos un vecino muy similar (formando una campana centrada en $\approx 0.89$). Segundo, la eficiencia de un algoritmo depende totalmente de cómo gestiona la memoria. El algoritmo A2 superó a A1 porque calcula todo al vuelo aprovechando la memoria caché, mientras que A1 se asfixia intentando guardar una matriz gigantesca e innecesaria en la RAM.
\section{Referencias}

\begin{itemize}
    \item Unidad 3: Notas del curso (Introducción a propiedades y operaciones básicas de estructuras y matrices en Julia).
    \item Gómez Fuentes, M. C., \& Cervantes Ojeda, J. (2014). Análisis de la complejidad algorítmica. En \textit{Introducción al Análisis y al Diseño de Algoritmos}. Universidad Autónoma Metropolitana.
\end{itemize}

\end{document}